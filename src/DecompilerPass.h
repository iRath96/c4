#ifndef Decompiler_h
#define Decompiler_h

#include "AST.h"
#include "Optimizer.h"

#include <map>
#include <vector>
#include <set>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wconversion"
#include <llvm/Pass.h>
#include <llvm/IR/Constants.h>
#include <llvm/Support/raw_ostream.h>
#pragma GCC diagnostic pop


namespace llvm {
	class BasicBlock;
	class Value;
	class PHINode;
	class Instruction;
}


namespace optimizer {

/**
 * Transforms LLVM IR back into (pseudo-) C code.
 * This is used to visualize the effects of optimizer passes.
 */
struct DecompilerPass : public llvm::FunctionPass {
	/**
	 * A reference to the optimizer which stores information on what options are enabled.
	 */
	const Optimizer *optimizer;

	static char ID;
	DecompilerPass(const Optimizer *optimizer)
	: FunctionPass(ID), optimizer(optimizer) {}

	void getAnalysisUsage(llvm::AnalysisUsage &info) const override;
	bool runOnFunction(llvm::Function &func) override;

	/**
	 * Stores for each block which PHI nodes have an incoming value coming from this block.
	 */
	std::map<llvm::BasicBlock *, std::vector<llvm::PHINode *>> phiRefs;
	/**
	 * Stores for each value which AST expression has been generated for it.
	 * For values that are used only once and have no side effects, this will contain
	 * the expression itself. For all others, a statement will be generated by the decompiler
	 * and this will store an IdentifierExpression referencing the result.
	 */
	std::map<llvm::Value *, ast::Ptr<ast::Expression>> vmap;

	/**
	 * Stores for each value what name has been assigned by the decompiler.
	 * The decompiler legalizes the names provided by the values, ensures
	 * that no naming conflicts happen and generates new names for unnamed
	 * values.
	 */
	std::map<llvm::Value *, std::string> names;
	/**
	 * The inverse mapping for `names`. This is used to verify if names have been assigned yet.
	 * @see names
	 * @todo not elegant
	 */
	std::map<std::string, llvm::Value *> namesReverse;

	/**
	 * The index of the last automatically generated name.
	 */
	int nameCounter = 0;

	/**
	 * Finds the name assigned to a value or creates one if needed.
	 */
	std::string resolveName(llvm::Value *value);

	/**
	 * Tries to find the AST expression that has been assigned to a value
	 * and falls back to creating an IdentifierExpression referencing its name.
	 */
	ast::Ptr<ast::Expression> resolve(llvm::Value *value);

	/**
	 * Finds the immediate dominator of a block.
	 */
	llvm::BasicBlock *findImmediateDominator(llvm::BasicBlock &block);

	/**
	 * Checks whether the provided blocks form a loop.
	 * @param header The loop header, which must dominated the loop body.
	 * @param body The loop body, which must (in)directly branch back to the loop header.
	 * @note This is not used atm, but has enormous potential!
	 */
	bool isLoop(llvm::BasicBlock *header, llvm::BasicBlock *body);

	/**
	 * Decompiles the provided basic block into the provided compound statement.
	 * This will try to recover control flow structures. Branches to other basic blocks are recursively bound
	 * if they are dominated, and referenced by a goto statement if they are not dominated.
	 * @param block The block that is to be decompiled
	 * @param [in,out] compound The compound statement that the decompiled code will be appended to.
	 * @param [in,out] join Set of basic blocks for which goto statement references have been created.
	 * @note It is crucial to understand that this function will not only bind the provided block, but it is also
	 *   responsible for binding all blocks that are dominated by the provided block by calling itself recursively.
	 *   This also means that join will never include blocks that are dominated by the provided basic block.
	 */
	void bindBlock(llvm::BasicBlock &block, ast::CompoundStatement &compound, std::set<llvm::BasicBlock *> &join);

	/**
	 * Decompiles instructions into AST nodes and creates statements in the provided compound statement.
	 * This does not handle control flow (i.e. the terminator instruction is ignored).
	 * @see vmap
	 * @see bindBlock
	 */
	void decompileInstructions(llvm::BasicBlock &block, ast::CompoundStatement &compound);

	/**
	 * Creates artificial assignment statements for all PHI nodes that reference the given block.
	 * @see phiRefs
	 */
	void resolvePHIRefs(llvm::BasicBlock &block, ast::CompoundStatement &compound);

	/**
	 * Simplifies compound statements by removing gotos for which the control flow does not
	 * change if they are omitted. One example of this is `if (…) { …; goto A; } A: …;`.
	 * This will also negate if conditions for `if (…); else …;` statements so they become easier to read.
	 * @param [in,out] body The statement to check for gotos. If this is not a compound statements,
	 *   no changes to the statement will be made.
	 * @param [in,out] refs Set of labels that have been referenced by gotos that could not be removed.
	 * @param follow The label of the block that executes after the provided statement.
	 * @return Whether the provided body is a compound statement that has become empty
	 */
	bool fixGotos(ast::Statement *body, std::set<std::string> &refs, ast::IdentifierLabel *follow = nullptr);
	/**
	 * Recursively removes labels that have no reference.
	 * @param [in,out] body The statement to check for labels.
	 * @param refs The set of labels that have a reference. All labels not in this set will be eliminated.
	 * @see fixGotos
	 */
	void fixLabels(ast::Statement *body, const std::set<std::string> &refs);

	/**
	 * Simplifies compound statement of only one statement by replacing them with their respective children.
	 * @param [in,out] stmt Will be overwritten in order to simplify the statement.
	 */
	void unwrapCompoundStatement(ast::Ptr<ast::Statement> &stmt);

	/**
	 * Negates an AST expression logically (e.g. `!x` becomes `x`, `a < 0` becomes `a >= 0`).
	 * @note This is used to simplify if statements of the form `if (…); else …;`.
	 * @see fixGotos
	 */
	void negateExpression(ast::ExpressionList &expr);

	/**
	 * Generates an ast node that describes an llvm type.
	 * @todo singletons!
	 */
	void decompileType(
		llvm::Type *type,
		ast::PtrVector<ast::TypeSpecifier> &specifiers,
		ast::PtrVector<ast::DeclaratorModifier> &modifiers
	);
};

}

#endif /* Decompiler_h */
